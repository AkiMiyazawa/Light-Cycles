# Light-Cycles

Light Cycles is a 2-player game inspired by the 1982 arcade game, Tron, implemented on the FPGA. The rules of Light Cycles are quite simple. The game starts from an aerial view, where each player controls a different colored light cycle on the grid. The light cycles move at a constant speed and players can turn their respective light cycles. As the light cycles move, they leave a wall behind them. If a player’s light cycle crashes into a wall or the sides of the screen, that player loses. On a loss, the winning player’s color is displayed on the entire screen.
The interface to the game includes the 5 buttons on the FPGA board. Each player is assigned 2 buttons to control their light cycle, corresponding the left (counterclockwise) or right (clockwise) turns. The 5th button is used to reset the game once a player wins.
The interface from the game includes the computer monitor and seven-segment display. We implement a VGA connection to enable our FPGA to write pixels on the screen. “3, 2, 1, GO” is displayed on the seven segment display of the FPGA board, at the beginning of the game.
In regards to game logic, we implement 3 game states: pre-game mode, game mode, and post-game mode. In pre-game mode, the seven segment display counts down: “3, 2, 1, GO”, and then the game begins. In game mode, the light cycles move at a constant speed until one cycle crashes. The cycles leave walls behind them and each is controlled by the 2 buttons explained above. In the post-game mode, the color of the winning player is displayed on the entire screen. To transition from pre-game mode to game mode, we wait for the counter to finish. To transition from game mode to post-game mode, we wait for a light cycle to crash. To transition from post-game mode to pre-game mode, we press the reset button.
Apart from the game interfaces and logic, the last design requirement is ease of use. We implement button debouncing on the 4 buttons used for turning. To ensure maximum responsiveness, we apply the same techniques used in the previous 2 labs: downsampling and implementing a buffer to detect positive edges. The reset button is not debounced, as the game logic is not affected if the reset button registers excess clicks.
